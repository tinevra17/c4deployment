'use strict';

const cryptoUtils = require('./cryptoUtils');
const RestQuery = require('./RestQuery');
const Parse = require('parse/node');

// An Auth object tells you who is requesting something and whether
// the master key was used.
// userObject is a Parse.User and can be null if there's no user.
function Auth({ config, cacheController = undefined, isMaster = false, isReadOnly = false, user, installationId }) {
  this.config = config;
  this.cacheController = cacheController || config && config.cacheController;
  this.installationId = installationId;
  this.isMaster = isMaster;
  this.user = user;
  this.isReadOnly = isReadOnly;

  // Assuming a users roles won't change during a single request, we'll
  // only load them once.
  this.userRoles = [];
  this.fetchedRoles = false;
  this.rolePromise = null;
}

// Whether this auth could possibly modify the given user id.
// It still could be forbidden via ACLs even if this returns true.
Auth.prototype.isUnauthenticated = function () {
  if (this.isMaster) {
    return false;
  }
  if (this.user) {
    return false;
  }
  return true;
};

// A helper to get a master-level Auth object
function master(config) {
  return new Auth({ config, isMaster: true });
}

// A helper to get a master-level Auth object
function readOnly(config) {
  return new Auth({ config, isMaster: true, isReadOnly: true });
}

// A helper to get a nobody-level Auth object
function nobody(config) {
  return new Auth({ config, isMaster: false });
}

// Returns a promise that resolves to an Auth object
const getAuthForSessionToken = async function ({ config, cacheController, sessionToken, installationId }) {
  cacheController = cacheController || config && config.cacheController;
  if (cacheController) {
    const userJSON = await cacheController.user.get(sessionToken);
    if (userJSON) {
      const cachedUser = Parse.Object.fromJSON(userJSON);
      return Promise.resolve(new Auth({ config, cacheController, isMaster: false, installationId, user: cachedUser }));
    }
  }

  let results;
  if (config) {
    const restOptions = {
      limit: 1,
      include: 'user'
    };

    const query = new RestQuery(config, master(config), '_Session', { sessionToken }, restOptions);
    results = (await query.execute()).results;
  } else {
    results = (await new Parse.Query(Parse.Session).limit(1).include('user').equalTo('sessionToken', sessionToken).find({ useMasterKey: true })).map(obj => obj.toJSON());
  }

  if (results.length !== 1 || !results[0]['user']) {
    throw new Parse.Error(Parse.Error.INVALID_SESSION_TOKEN, 'Invalid session token');
  }
  const now = new Date(),
        expiresAt = results[0].expiresAt ? new Date(results[0].expiresAt.iso) : undefined;
  if (expiresAt < now) {
    throw new Parse.Error(Parse.Error.INVALID_SESSION_TOKEN, 'Session token is expired.');
  }
  const obj = results[0]['user'];
  delete obj.password;
  obj['className'] = '_User';
  obj['sessionToken'] = sessionToken;
  if (cacheController) {
    cacheController.user.put(sessionToken, obj);
  }
  const userObject = Parse.Object.fromJSON(obj);
  return new Auth({ config, cacheController, isMaster: false, installationId, user: userObject });
};

var getAuthForLegacySessionToken = function ({ config, sessionToken, installationId }) {
  var restOptions = {
    limit: 1
  };
  var query = new RestQuery(config, master(config), '_User', { sessionToken }, restOptions);
  return query.execute().then(response => {
    var results = response.results;
    if (results.length !== 1) {
      throw new Parse.Error(Parse.Error.INVALID_SESSION_TOKEN, 'invalid legacy session token');
    }
    const obj = results[0];
    obj.className = '_User';
    const userObject = Parse.Object.fromJSON(obj);
    return new Auth({ config, isMaster: false, installationId, user: userObject });
  });
};

// Returns a promise that resolves to an array of role names
Auth.prototype.getUserRoles = function () {
  if (this.isMaster || !this.user) {
    return Promise.resolve([]);
  }
  if (this.fetchedRoles) {
    return Promise.resolve(this.userRoles);
  }
  if (this.rolePromise) {
    return this.rolePromise;
  }
  this.rolePromise = this._loadRoles();
  return this.rolePromise;
};

Auth.prototype.getRolesForUser = function () {
  if (this.config) {
    const restWhere = {
      'users': {
        __type: 'Pointer',
        className: '_User',
        objectId: this.user.id
      }
    };
    const query = new RestQuery(this.config, master(this.config), '_Role', restWhere, {});
    return query.execute().then(({ results }) => results);
  }

  return new Parse.Query(Parse.Role).equalTo('users', this.user).find({ useMasterKey: true }).then(results => results.map(obj => obj.toJSON()));
};

// Iterates through the role tree and compiles a user's roles
Auth.prototype._loadRoles = async function () {
  if (this.cacheController) {
    const cachedRoles = await this.cacheController.role.get(this.user.id);
    if (cachedRoles != null) {
      this.fetchedRoles = true;
      this.userRoles = cachedRoles;
      return cachedRoles;
    }
  }

  // First get the role ids this user is directly a member of
  const results = await this.getRolesForUser();
  if (!results.length) {
    this.userRoles = [];
    this.fetchedRoles = true;
    this.rolePromise = null;

    this.cacheRoles();
    return this.userRoles;
  }

  const rolesMap = results.reduce((m, r) => {
    m.names.push(r.name);
    m.ids.push(r.objectId);
    return m;
  }, { ids: [], names: [] });

  // run the recursive finding
  const roleNames = await this._getAllRolesNamesForRoleIds(rolesMap.ids, rolesMap.names);
  this.userRoles = roleNames.map(r => {
    return 'role:' + r;
  });
  this.fetchedRoles = true;
  this.rolePromise = null;
  this.cacheRoles();
  return this.userRoles;
};

Auth.prototype.cacheRoles = function () {
  if (!this.cacheController) {
    return false;
  }
  this.cacheController.role.put(this.user.id, Array(...this.userRoles));
  return true;
};

Auth.prototype.getRolesByIds = function (ins) {
  const roles = ins.map(id => {
    return {
      __type: 'Pointer',
      className: '_Role',
      objectId: id
    };
  });
  const restWhere = { 'roles': { '$in': roles } };

  // Build an OR query across all parentRoles
  if (!this.config) {
    return new Parse.Query(Parse.Role).containedIn('roles', ins.map(id => {
      const role = new Parse.Object(Parse.Role);
      role.id = id;
      return role;
    })).find({ useMasterKey: true }).then(results => results.map(obj => obj.toJSON()));
  }

  return new RestQuery(this.config, master(this.config), '_Role', restWhere, {}).execute().then(({ results }) => results);
};

// Given a list of roleIds, find all the parent roles, returns a promise with all names
Auth.prototype._getAllRolesNamesForRoleIds = function (roleIDs, names = [], queriedRoles = {}) {
  const ins = roleIDs.filter(roleID => {
    const wasQueried = queriedRoles[roleID] !== true;
    queriedRoles[roleID] = true;
    return wasQueried;
  });

  // all roles are accounted for, return the names
  if (ins.length == 0) {
    return Promise.resolve([...new Set(names)]);
  }

  return this.getRolesByIds(ins).then(results => {
    // Nothing found
    if (!results.length) {
      return Promise.resolve(names);
    }
    // Map the results with all Ids and names
    const resultMap = results.reduce((memo, role) => {
      memo.names.push(role.name);
      memo.ids.push(role.objectId);
      return memo;
    }, { ids: [], names: [] });
    // store the new found names
    names = names.concat(resultMap.names);
    // find the next ones, circular roles will be cut
    return this._getAllRolesNamesForRoleIds(resultMap.ids, names, queriedRoles);
  }).then(names => {
    return Promise.resolve([...new Set(names)]);
  });
};

const createSession = function (config, {
  userId,
  createdWith,
  installationId,
  additionalSessionData
}) {
  const token = 'r:' + cryptoUtils.newToken();
  const expiresAt = config.generateSessionExpiresAt();
  const sessionData = {
    sessionToken: token,
    user: {
      __type: 'Pointer',
      className: '_User',
      objectId: userId
    },
    createdWith,
    restricted: false,
    expiresAt: Parse._encode(expiresAt)
  };

  if (installationId) {
    sessionData.installationId = installationId;
  }

  Object.assign(sessionData, additionalSessionData);
  // We need to import RestWrite at this point for the cyclic dependency it has to it
  const RestWrite = require('./RestWrite');

  return {
    sessionData,
    createSession: () => new RestWrite(config, master(config), '_Session', null, sessionData).execute()
  };
};

module.exports = {
  Auth,
  master,
  nobody,
  readOnly,
  getAuthForSessionToken,
  getAuthForLegacySessionToken,
  createSession
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9BdXRoLmpzIl0sIm5hbWVzIjpbImNyeXB0b1V0aWxzIiwicmVxdWlyZSIsIlJlc3RRdWVyeSIsIlBhcnNlIiwiQXV0aCIsImNvbmZpZyIsImNhY2hlQ29udHJvbGxlciIsInVuZGVmaW5lZCIsImlzTWFzdGVyIiwiaXNSZWFkT25seSIsInVzZXIiLCJpbnN0YWxsYXRpb25JZCIsInVzZXJSb2xlcyIsImZldGNoZWRSb2xlcyIsInJvbGVQcm9taXNlIiwicHJvdG90eXBlIiwiaXNVbmF1dGhlbnRpY2F0ZWQiLCJtYXN0ZXIiLCJyZWFkT25seSIsIm5vYm9keSIsImdldEF1dGhGb3JTZXNzaW9uVG9rZW4iLCJzZXNzaW9uVG9rZW4iLCJ1c2VySlNPTiIsImdldCIsImNhY2hlZFVzZXIiLCJPYmplY3QiLCJmcm9tSlNPTiIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVzdWx0cyIsInJlc3RPcHRpb25zIiwibGltaXQiLCJpbmNsdWRlIiwicXVlcnkiLCJleGVjdXRlIiwiUXVlcnkiLCJTZXNzaW9uIiwiZXF1YWxUbyIsImZpbmQiLCJ1c2VNYXN0ZXJLZXkiLCJtYXAiLCJvYmoiLCJ0b0pTT04iLCJsZW5ndGgiLCJFcnJvciIsIklOVkFMSURfU0VTU0lPTl9UT0tFTiIsIm5vdyIsIkRhdGUiLCJleHBpcmVzQXQiLCJpc28iLCJwYXNzd29yZCIsInB1dCIsInVzZXJPYmplY3QiLCJnZXRBdXRoRm9yTGVnYWN5U2Vzc2lvblRva2VuIiwidGhlbiIsInJlc3BvbnNlIiwiY2xhc3NOYW1lIiwiZ2V0VXNlclJvbGVzIiwiX2xvYWRSb2xlcyIsImdldFJvbGVzRm9yVXNlciIsInJlc3RXaGVyZSIsIl9fdHlwZSIsIm9iamVjdElkIiwiaWQiLCJSb2xlIiwiY2FjaGVkUm9sZXMiLCJyb2xlIiwiY2FjaGVSb2xlcyIsInJvbGVzTWFwIiwicmVkdWNlIiwibSIsInIiLCJuYW1lcyIsInB1c2giLCJuYW1lIiwiaWRzIiwicm9sZU5hbWVzIiwiX2dldEFsbFJvbGVzTmFtZXNGb3JSb2xlSWRzIiwiQXJyYXkiLCJnZXRSb2xlc0J5SWRzIiwiaW5zIiwicm9sZXMiLCJjb250YWluZWRJbiIsInJvbGVJRHMiLCJxdWVyaWVkUm9sZXMiLCJmaWx0ZXIiLCJyb2xlSUQiLCJ3YXNRdWVyaWVkIiwiU2V0IiwicmVzdWx0TWFwIiwibWVtbyIsImNvbmNhdCIsImNyZWF0ZVNlc3Npb24iLCJ1c2VySWQiLCJjcmVhdGVkV2l0aCIsImFkZGl0aW9uYWxTZXNzaW9uRGF0YSIsInRva2VuIiwibmV3VG9rZW4iLCJnZW5lcmF0ZVNlc3Npb25FeHBpcmVzQXQiLCJzZXNzaW9uRGF0YSIsInJlc3RyaWN0ZWQiLCJfZW5jb2RlIiwiYXNzaWduIiwiUmVzdFdyaXRlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7QUFBQSxNQUFNQSxjQUFjQyxRQUFRLGVBQVIsQ0FBcEI7QUFDQSxNQUFNQyxZQUFZRCxRQUFRLGFBQVIsQ0FBbEI7QUFDQSxNQUFNRSxRQUFRRixRQUFRLFlBQVIsQ0FBZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTRyxJQUFULENBQWMsRUFBRUMsTUFBRixFQUFVQyxrQkFBa0JDLFNBQTVCLEVBQXVDQyxXQUFXLEtBQWxELEVBQXlEQyxhQUFhLEtBQXRFLEVBQTZFQyxJQUE3RSxFQUFtRkMsY0FBbkYsRUFBZCxFQUFtSDtBQUNqSCxPQUFLTixNQUFMLEdBQWNBLE1BQWQ7QUFDQSxPQUFLQyxlQUFMLEdBQXVCQSxtQkFBb0JELFVBQVVBLE9BQU9DLGVBQTVEO0FBQ0EsT0FBS0ssY0FBTCxHQUFzQkEsY0FBdEI7QUFDQSxPQUFLSCxRQUFMLEdBQWdCQSxRQUFoQjtBQUNBLE9BQUtFLElBQUwsR0FBWUEsSUFBWjtBQUNBLE9BQUtELFVBQUwsR0FBa0JBLFVBQWxCOztBQUVBO0FBQ0E7QUFDQSxPQUFLRyxTQUFMLEdBQWlCLEVBQWpCO0FBQ0EsT0FBS0MsWUFBTCxHQUFvQixLQUFwQjtBQUNBLE9BQUtDLFdBQUwsR0FBbUIsSUFBbkI7QUFDRDs7QUFFRDtBQUNB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QUFZaUcsUUFBWixFQUFyQjtBQUNBLFFBQU1qRCxZQUFZM0MsT0FBTzZGLHdCQUFQLEVBQWxCO0FBQ0EsUUFBTUMsY0FBYztBQUNsQjlFLGtCQUFjMkUsS0FESTtBQUVsQnRGLFVBQU07QUFDSm1ELGNBQVEsU0FESjtBQUVKTCxpQkFBVyxPQUZQO0FBR0pNLGdCQUFVK0I7QUFITixLQUZZO0FBT2xCQyxlQVBrQjtBQVFsQk0sZ0JBQVksS0FSTTtBQVNsQnBELGVBQVc3QyxNQUFNa0csT0FBTixDQUFjckQsU0FBZDtBQVRPLEdBQXBCOztBQVlBLE1BQUlyQyxjQUFKLEVBQW9CO0FBQ2xCd0YsZ0JBQVl4RixjQUFaLEdBQTZCQSxjQUE3QjtBQUNEOztBQUVEYyxTQUFPNkUsTUFBUCxDQUFjSCxXQUFkLEVBQTJCSixxQkFBM0I7QUFDQTtBQUNBLFFBQU1RLFlBQVl0RyxRQUFRLGFBQVIsQ0FBbEI7O0FBRUEsU0FBTztBQUNMa0csZUFESztBQUVMUCxtQkFBZSxNQUFNLElBQUlXLFNBQUosQ0FBY2xHLE1BQWQsRUFBc0JZLE9BQU9aLE1BQVAsQ0FBdEIsRUFBc0MsVUFBdEMsRUFBa0QsSUFBbEQsRUFBd0Q4RixXQUF4RCxFQUFxRWpFLE9BQXJFO0FBRmhCLEdBQVA7QUFJRCxDQWhDRDs7QUFrQ0FzRSxPQUFPQyxPQUFQLEdBQWlCO0FBQ2ZyRyxNQURlO0FBRWZhLFFBRmU7QUFHZkUsUUFIZTtBQUlmRCxVQUplO0FBS2ZFLHdCQUxlO0FBTWZpQyw4QkFOZTtBQU9mdUM7QUFQZSxDQUFqQiIsImZpbGUiOiJBdXRoLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY3J5cHRvVXRpbHMgPSByZXF1aXJlKCcuL2NyeXB0b1V0aWxzJyk7XG5jb25zdCBSZXN0UXVlcnkgPSByZXF1aXJlKCcuL1Jlc3RRdWVyeScpO1xuY29uc3QgUGFyc2UgPSByZXF1aXJlKCdwYXJzZS9ub2RlJyk7XG5cbi8vIEFuIEF1dGggb2JqZWN0IHRlbGxzIHlvdSB3aG8gaXMgcmVxdWVzdGluZyBzb21ldGhpbmcgYW5kIHdoZXRoZXJcbi8vIHRoZSBtYXN0ZXIga2V5IHdhcyB1c2VkLlxuLy8gdXNlck9iamVjdCBpcyBhIFBhcnNlLlVzZXIgYW5kIGNhbiBiZSBudWxsIGlmIHRoZXJlJ3Mgbm8gdXNlci5cbmZ1bmN0aW9uIEF1dGgoeyBjb25maWcsIGNhY2hlQ29udHJvbGxlciA9IHVuZGVmaW5lZCwgaXNNYXN0ZXIgPSBmYWxzZSwgaXNSZWFkT25seSA9IGZhbHNlLCB1c2VyLCBpbnN0YWxsYXRpb25JZCB9KSB7XG4gIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICB0aGlzLmNhY2hlQ29udHJvbGxlciA9IGNhY2hlQ29udHJvbGxlciB8fCAoY29uZmlnICYmIGNvbmZpZy5jYWNoZUNvbnRyb2xsZXIpO1xuICB0aGlzLmluc3RhbGxhdGlvbklkID0gaW5zdGFsbGF0aW9uSWQ7XG4gIHRoaXMuaXNNYXN0ZXIgPSBpc01hc3RlcjtcbiAgdGhpcy51c2VyID0gdXNlcjtcbiAgdGhpcy5pc1JlYWRPbmx5ID0gaXNSZWFkT25seTtcblxuICAvLyBBc3N1bWluZyBhIHVzZXJzIHJvbGVzIHdvbid0IGNoYW5nZSBkdXJpbmcgYSBzaW5nbGUgcmVxdWVzdCwgd2UnbGxcbiAgLy8gb25seSBsb2FkIHRoZW0gb25jZS5cbiAgdGhpcy51c2VyUm9sZXMgPSBbXTtcbiAgdGhpcy5mZXRjaGVkUm9sZXMgPSBmYWxzZTtcbiAgdGhpcy5yb2xlUHJvbWlzZSA9IG51bGw7XG59XG5cbi8vIFdoZXRoZXIgdGhpcyBhdXRoIGNvdWxkIHBvc3NpYmx5IG1vZGlmeSB0aGUgZ2l2ZW4gdXNlciBpZC5cbi8vIEl0IHN0aWxsIGNvdWxkIGJlIGZvcmJpZGRlbiB2aWEgQUNMcyBldmVuIGlmIHRoaXMgcmV0dXJucyB0cnVlLlxuQXV0aC5wcm90b3R5cGUuaXNVbmF1dGhlbnRpY2F0ZWQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuaXNNYXN0ZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHRoaXMudXNlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIEEgaGVscGVyIHRvIGdldCBhIG1hc3Rlci1sZXZlbCBBdXRoIG9iamVjdFxuZnVuY3Rpb24gbWFzdGVyKGNvbmZpZykge1xuICByZXR1cm4gbmV3IEF1dGgoeyBjb25maWcsIGlzTWFzdGVyOiB0cnVlIH0pO1xufVxuXG4vLyBBIGhlbHBlciB0byBnZXQgYSBtYXN0ZXItbGV2ZWwgQXV0aCBvYmplY3RcbmZ1bmN0aW9uIHJlYWRPbmx5KGNvbmZpZykge1xuICByZXR1cm4gbmV3IEF1dGgoeyBjb25maWcsIGlzTWFzdGVyOiB0cnVlLCBpc1JlYWRPbmx5OiB0cnVlIH0pO1xufVxuXG4vLyBBIGhlbHBlciB0byBnZXQgYSBub2JvZHktbGV2ZWwgQXV0aCBvYmplY3RcbmZ1bmN0aW9uIG5vYm9keShjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBBdXRoKHsgY29uZmlnLCBpc01hc3RlcjogZmFsc2UgfSk7XG59XG5cblxuLy8gUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBBdXRoIG9iamVjdFxuY29uc3QgZ2V0QXV0aEZvclNlc3Npb25Ub2tlbiA9IGFzeW5jIGZ1bmN0aW9uKHsgY29uZmlnLCBjYWNoZUNvbnRyb2xsZXIsIHNlc3Npb25Ub2tlbiwgaW5zdGFsbGF0aW9uSWQgfSkge1xuICBjYWNoZUNvbnRyb2xsZXIgPSBjYWNoZUNvbnRyb2xsZXIgfHwgKGNvbmZpZyAmJiBjb25maWcuY2FjaGVDb250cm9sbGVyKTtcbiAgaWYgKGNhY2hlQ29udHJvbGxlcikge1xuICAgIGNvbnN0IHVzZXJKU09OID0gYXdhaXQgY2FjaGVDb250cm9sbGVyLnVzZXIuZ2V0KHNlc3Npb25Ub2tlbik7XG4gICAgaWYgKHVzZXJKU09OKSB7XG4gICAgICBjb25zdCBjYWNoZWRVc2VyID0gUGFyc2UuT2JqZWN0LmZyb21KU09OKHVzZXJKU09OKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEF1dGgoe2NvbmZpZywgY2FjaGVDb250cm9sbGVyLCBpc01hc3RlcjogZmFsc2UsIGluc3RhbGxhdGlvbklkLCB1c2VyOiBjYWNoZWRVc2VyfSkpO1xuICAgIH1cbiAgfVxuXG4gIGxldCByZXN1bHRzO1xuICBpZiAoY29uZmlnKSB7XG4gICAgY29uc3QgcmVzdE9wdGlvbnMgPSB7XG4gICAgICBsaW1pdDogMSxcbiAgICAgIGluY2x1ZGU6ICd1c2VyJ1xuICAgIH07XG5cbiAgICBjb25zdCBxdWVyeSA9IG5ldyBSZXN0UXVlcnkoY29uZmlnLCBtYXN0ZXIoY29uZmlnKSwgJ19TZXNzaW9uJywgeyBzZXNzaW9uVG9rZW4gfSwgcmVzdE9wdGlvbnMpO1xuICAgIHJlc3VsdHMgPSAoYXdhaXQgcXVlcnkuZXhlY3V0ZSgpKS5yZXN1bHRzO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdHMgPSAoYXdhaXQgbmV3IFBhcnNlLlF1ZXJ5KFBhcnNlLlNlc3Npb24pXG4gICAgICAubGltaXQoMSlcbiAgICAgIC5pbmNsdWRlKCd1c2VyJylcbiAgICAgIC5lcXVhbFRvKCdzZXNzaW9uVG9rZW4nLCBzZXNzaW9uVG9rZW4pXG4gICAgICAuZmluZCh7IHVzZU1hc3RlcktleTogdHJ1ZSB9KSkubWFwKChvYmopID0+IG9iai50b0pTT04oKSlcbiAgfVxuXG4gIGlmIChyZXN1bHRzLmxlbmd0aCAhPT0gMSB8fCAhcmVzdWx0c1swXVsndXNlciddKSB7XG4gICAgdGhyb3cgbmV3IFBhcnNlLkVycm9yKFBhcnNlLkVycm9yLklOVkFMSURfU0VTU0lPTl9UT0tFTiwgJ0ludmFsaWQgc2Vzc2lvbiB0b2tlbicpO1xuICB9XG4gIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCksXG4gICAgZXhwaXJlc0F0ID0gcmVzdWx0c1swXS5leHBpcmVzQXQgPyBuZXcgRGF0ZShyZXN1bHRzWzBdLmV4cGlyZXNBdC5pc28pIDogdW5kZWZpbmVkO1xuICBpZiAoZXhwaXJlc0F0IDwgbm93KSB7XG4gICAgdGhyb3cgbmV3IFBhcnNlLkVycm9yKFBhcnNlLkVycm9yLklOVkFMSURfU0VTU0lPTl9UT0tFTixcbiAgICAgICdTZXNzaW9uIHRva2VuIGlzIGV4cGlyZWQuJyk7XG4gIH1cbiAgY29uc3Qgb2JqID0gcmVzdWx0c1swXVsndXNlciddO1xuICBkZWxldGUgb2JqLnBhc3N3b3JkO1xuICBvYmpbJ2NsYXNzTmFtZSddID0gJ19Vc2VyJztcbiAgb2JqWydzZXNzaW9uVG9rZW4nXSA9IHNlc3Npb25Ub2tlbjtcbiAgaWYgKGNhY2hlQ29udHJvbGxlcikge1xuICAgIGNhY2hlQ29udHJvbGxlci51c2VyLnB1dChzZXNzaW9uVG9rZW4sIG9iaik7XG4gIH1cbiAgY29uc3QgdXNlck9iamVjdCA9IFBhcnNlLk9iamVjdC5mcm9tSlNPTihvYmopO1xuICByZXR1cm4gbmV3IEF1dGgoeyBjb25maWcsIGNhY2hlQ29udHJvbGxlciwgaXNNYXN0ZXI6IGZhbHNlLCBpbnN0YWxsYXRpb25JZCwgdXNlcjogdXNlck9iamVjdCB9KTtcbn07XG5cbnZhciBnZXRBdXRoRm9yTGVnYWN5U2Vzc2lvblRva2VuID0gZnVuY3Rpb24oeyBjb25maWcsIHNlc3Npb25Ub2tlbiwgaW5zdGFsbGF0aW9uSWQgfSkge1xuICB2YXIgcmVzdE9wdGlvbnMgPSB7XG4gICAgbGltaXQ6IDFcbiAgfTtcbiAgdmFyIHF1ZXJ5ID0gbmV3IFJlc3RRdWVyeShjb25maWcsIG1hc3Rlcihjb25maWcpLCAnX1VzZXInLCB7IHNlc3Npb25Ub2tlbiB9LCByZXN0T3B0aW9ucyk7XG4gIHJldHVybiBxdWVyeS5leGVjdXRlKCkudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICB2YXIgcmVzdWx0cyA9IHJlc3BvbnNlLnJlc3VsdHM7XG4gICAgaWYgKHJlc3VsdHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoUGFyc2UuRXJyb3IuSU5WQUxJRF9TRVNTSU9OX1RPS0VOLCAnaW52YWxpZCBsZWdhY3kgc2Vzc2lvbiB0b2tlbicpO1xuICAgIH1cbiAgICBjb25zdCBvYmogPSByZXN1bHRzWzBdO1xuICAgIG9iai5jbGFzc05hbWUgPSAnX1VzZXInO1xuICAgIGNvbnN0IHVzZXJPYmplY3QgPSBQYXJzZS5PYmplY3QuZnJvbUpTT04ob2JqKTtcbiAgICByZXR1cm4gbmV3IEF1dGgoeyBjb25maWcsIGlzTWFzdGVyOiBmYWxzZSwgaW5zdGFsbGF0aW9uSWQsIHVzZXI6IHVzZXJPYmplY3QgfSk7XG4gIH0pO1xufVxuXG4vLyBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIGFycmF5IG9mIHJvbGUgbmFtZXNcbkF1dGgucHJvdG90eXBlLmdldFVzZXJSb2xlcyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5pc01hc3RlciB8fCAhdGhpcy51c2VyKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gIH1cbiAgaWYgKHRoaXMuZmV0Y2hlZFJvbGVzKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLnVzZXJSb2xlcyk7XG4gIH1cbiAgaWYgKHRoaXMucm9sZVByb21pc2UpIHtcbiAgICByZXR1cm4gdGhpcy5yb2xlUHJvbWlzZTtcbiAgfVxuICB0aGlzLnJvbGVQcm9taXNlID0gdGhpcy5fbG9hZFJvbGVzKCk7XG4gIHJldHVybiB0aGlzLnJvbGVQcm9taXNlO1xufTtcblxuQXV0aC5wcm90b3R5cGUuZ2V0Um9sZXNGb3JVc2VyID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmNvbmZpZykge1xuICAgIGNvbnN0IHJlc3RXaGVyZSA9IHtcbiAgICAgICd1c2Vycyc6IHtcbiAgICAgICAgX190eXBlOiAnUG9pbnRlcicsXG4gICAgICAgIGNsYXNzTmFtZTogJ19Vc2VyJyxcbiAgICAgICAgb2JqZWN0SWQ6IHRoaXMudXNlci5pZFxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcXVlcnkgPSBuZXcgUmVzdFF1ZXJ5KHRoaXMuY29uZmlnLCBtYXN0ZXIodGhpcy5jb25maWcpLCAnX1JvbGUnLCByZXN0V2hlcmUsIHt9KTtcbiAgICByZXR1cm4gcXVlcnkuZXhlY3V0ZSgpLnRoZW4oKHsgcmVzdWx0cyB9KSA9PiByZXN1bHRzKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUGFyc2UuUXVlcnkoUGFyc2UuUm9sZSlcbiAgICAuZXF1YWxUbygndXNlcnMnLCB0aGlzLnVzZXIpXG4gICAgLmZpbmQoeyB1c2VNYXN0ZXJLZXk6IHRydWUgfSlcbiAgICAudGhlbigocmVzdWx0cykgPT4gcmVzdWx0cy5tYXAoKG9iaikgPT4gb2JqLnRvSlNPTigpKSk7XG59XG5cbi8vIEl0ZXJhdGVzIHRocm91Z2ggdGhlIHJvbGUgdHJlZSBhbmQgY29tcGlsZXMgYSB1c2VyJ3Mgcm9sZXNcbkF1dGgucHJvdG90eXBlLl9sb2FkUm9sZXMgPSBhc3luYyBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuY2FjaGVDb250cm9sbGVyKSB7XG4gICAgY29uc3QgY2FjaGVkUm9sZXMgPSBhd2FpdCB0aGlzLmNhY2hlQ29udHJvbGxlci5yb2xlLmdldCh0aGlzLnVzZXIuaWQpO1xuICAgIGlmIChjYWNoZWRSb2xlcyAhPSBudWxsKSB7XG4gICAgICB0aGlzLmZldGNoZWRSb2xlcyA9IHRydWU7XG4gICAgICB0aGlzLnVzZXJSb2xlcyA9IGNhY2hlZFJvbGVzO1xuICAgICAgcmV0dXJuIGNhY2hlZFJvbGVzO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZpcnN0IGdldCB0aGUgcm9sZSBpZHMgdGhpcyB1c2VyIGlzIGRpcmVjdGx5IGEgbWVtYmVyIG9mXG4gIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCB0aGlzLmdldFJvbGVzRm9yVXNlcigpO1xuICBpZiAoIXJlc3VsdHMubGVuZ3RoKSB7XG4gICAgdGhpcy51c2VyUm9sZXMgPSBbXTtcbiAgICB0aGlzLmZldGNoZWRSb2xlcyA9IHRydWU7XG4gICAgdGhpcy5yb2xlUHJvbWlzZSA9IG51bGw7XG5cbiAgICB0aGlzLmNhY2hlUm9sZXMoKTtcbiAgICByZXR1cm4gdGhpcy51c2VyUm9sZXM7XG4gIH1cblxuICBjb25zdCByb2xlc01hcCA9IHJlc3VsdHMucmVkdWNlKChtLCByKSA9PiB7XG4gICAgbS5uYW1lcy5wdXNoKHIubmFtZSk7XG4gICAgbS5pZHMucHVzaChyLm9iamVjdElkKTtcbiAgICByZXR1cm4gbTtcbiAgfSwge2lkczogW10sIG5hbWVzOiBbXX0pO1xuXG4gIC8vIHJ1biB0aGUgcmVjdXJzaXZlIGZpbmRpbmdcbiAgY29uc3Qgcm9sZU5hbWVzID0gYXdhaXQgdGhpcy5fZ2V0QWxsUm9sZXNOYW1lc0ZvclJvbGVJZHMocm9sZXNNYXAuaWRzLCByb2xlc01hcC5uYW1lcyk7XG4gIHRoaXMudXNlclJvbGVzID0gcm9sZU5hbWVzLm1hcCgocikgPT4ge1xuICAgIHJldHVybiAncm9sZTonICsgcjtcbiAgfSk7XG4gIHRoaXMuZmV0Y2hlZFJvbGVzID0gdHJ1ZTtcbiAgdGhpcy5yb2xlUHJvbWlzZSA9IG51bGw7XG4gIHRoaXMuY2FjaGVSb2xlcygpO1xuICByZXR1cm4gdGhpcy51c2VyUm9sZXM7XG59O1xuXG5BdXRoLnByb3RvdHlwZS5jYWNoZVJvbGVzID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5jYWNoZUNvbnRyb2xsZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdGhpcy5jYWNoZUNvbnRyb2xsZXIucm9sZS5wdXQodGhpcy51c2VyLmlkLCBBcnJheSguLi50aGlzLnVzZXJSb2xlcykpO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuQXV0aC5wcm90b3R5cGUuZ2V0Um9sZXNCeUlkcyA9IGZ1bmN0aW9uKGlucykge1xuICBjb25zdCByb2xlcyA9IGlucy5tYXAoKGlkKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9fdHlwZTogJ1BvaW50ZXInLFxuICAgICAgY2xhc3NOYW1lOiAnX1JvbGUnLFxuICAgICAgb2JqZWN0SWQ6IGlkXG4gICAgfVxuICB9KTtcbiAgY29uc3QgcmVzdFdoZXJlID0geyAncm9sZXMnOiB7ICckaW4nOiByb2xlcyB9fTtcblxuICAvLyBCdWlsZCBhbiBPUiBxdWVyeSBhY3Jvc3MgYWxsIHBhcmVudFJvbGVzXG4gIGlmICghdGhpcy5jb25maWcpIHtcbiAgICByZXR1cm4gbmV3IFBhcnNlLlF1ZXJ5KFBhcnNlLlJvbGUpXG4gICAgICAuY29udGFpbmVkSW4oJ3JvbGVzJywgaW5zLm1hcCgoaWQpID0+IHtcbiAgICAgICAgY29uc3Qgcm9sZSA9IG5ldyBQYXJzZS5PYmplY3QoUGFyc2UuUm9sZSk7XG4gICAgICAgIHJvbGUuaWQgPSBpZDtcbiAgICAgICAgcmV0dXJuIHJvbGU7XG4gICAgICB9KSlcbiAgICAgIC5maW5kKHsgdXNlTWFzdGVyS2V5OiB0cnVlIH0pXG4gICAgICAudGhlbigocmVzdWx0cykgPT4gcmVzdWx0cy5tYXAoKG9iaikgPT4gb2JqLnRvSlNPTigpKSk7XG4gIH1cblxuICByZXR1cm4gbmV3IFJlc3RRdWVyeSh0aGlzLmNvbmZpZywgbWFzdGVyKHRoaXMuY29uZmlnKSwgJ19Sb2xlJywgcmVzdFdoZXJlLCB7fSlcbiAgICAuZXhlY3V0ZSgpXG4gICAgLnRoZW4oKHsgcmVzdWx0cyB9KSA9PiByZXN1bHRzKTtcbn1cblxuLy8gR2l2ZW4gYSBsaXN0IG9mIHJvbGVJZHMsIGZpbmQgYWxsIHRoZSBwYXJlbnQgcm9sZXMsIHJldHVybnMgYSBwcm9taXNlIHdpdGggYWxsIG5hbWVzXG5BdXRoLnByb3RvdHlwZS5fZ2V0QWxsUm9sZXNOYW1lc0ZvclJvbGVJZHMgPSBmdW5jdGlvbihyb2xlSURzLCBuYW1lcyA9IFtdLCBxdWVyaWVkUm9sZXMgPSB7fSkge1xuICBjb25zdCBpbnMgPSByb2xlSURzLmZpbHRlcigocm9sZUlEKSA9PiB7XG4gICAgY29uc3Qgd2FzUXVlcmllZCA9IHF1ZXJpZWRSb2xlc1tyb2xlSURdICE9PSB0cnVlO1xuICAgIHF1ZXJpZWRSb2xlc1tyb2xlSURdID0gdHJ1ZTtcbiAgICByZXR1cm4gd2FzUXVlcmllZDtcbiAgfSk7XG5cbiAgLy8gYWxsIHJvbGVzIGFyZSBhY2NvdW50ZWQgZm9yLCByZXR1cm4gdGhlIG5hbWVzXG4gIGlmIChpbnMubGVuZ3RoID09IDApIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFsuLi5uZXcgU2V0KG5hbWVzKV0pO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZ2V0Um9sZXNCeUlkcyhpbnMpLnRoZW4oKHJlc3VsdHMpID0+IHtcbiAgICAvLyBOb3RoaW5nIGZvdW5kXG4gICAgaWYgKCFyZXN1bHRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuYW1lcyk7XG4gICAgfVxuICAgIC8vIE1hcCB0aGUgcmVzdWx0cyB3aXRoIGFsbCBJZHMgYW5kIG5hbWVzXG4gICAgY29uc3QgcmVzdWx0TWFwID0gcmVzdWx0cy5yZWR1Y2UoKG1lbW8sIHJvbGUpID0+IHtcbiAgICAgIG1lbW8ubmFtZXMucHVzaChyb2xlLm5hbWUpO1xuICAgICAgbWVtby5pZHMucHVzaChyb2xlLm9iamVjdElkKTtcbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH0sIHtpZHM6IFtdLCBuYW1lczogW119KTtcbiAgICAvLyBzdG9yZSB0aGUgbmV3IGZvdW5kIG5hbWVzXG4gICAgbmFtZXMgPSBuYW1lcy5jb25jYXQocmVzdWx0TWFwLm5hbWVzKTtcbiAgICAvLyBmaW5kIHRoZSBuZXh0IG9uZXMsIGNpcmN1bGFyIHJvbGVzIHdpbGwgYmUgY3V0XG4gICAgcmV0dXJuIHRoaXMuX2dldEFsbFJvbGVzTmFtZXNGb3JSb2xlSWRzKHJlc3VsdE1hcC5pZHMsIG5hbWVzLCBxdWVyaWVkUm9sZXMpXG4gIH0pLnRoZW4oKG5hbWVzKSA9PiB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbLi4ubmV3IFNldChuYW1lcyldKVxuICB9KVxufVxuXG5jb25zdCBjcmVhdGVTZXNzaW9uID0gZnVuY3Rpb24oY29uZmlnLCB7XG4gIHVzZXJJZCxcbiAgY3JlYXRlZFdpdGgsXG4gIGluc3RhbGxhdGlvbklkLFxuICBhZGRpdGlvbmFsU2Vzc2lvbkRhdGEsXG59KSB7XG4gIGNvbnN0IHRva2VuID0gJ3I6JyArIGNyeXB0b1V0aWxzLm5ld1Rva2VuKCk7XG4gIGNvbnN0IGV4cGlyZXNBdCA9IGNvbmZpZy5nZW5lcmF0ZVNlc3Npb25FeHBpcmVzQXQoKTtcbiAgY29uc3Qgc2Vzc2lvbkRhdGEgPSB7XG4gICAgc2Vzc2lvblRva2VuOiB0b2tlbixcbiAgICB1c2VyOiB7XG4gICAgICBfX3R5cGU6ICdQb2ludGVyJyxcbiAgICAgIGNsYXNzTmFtZTogJ19Vc2VyJyxcbiAgICAgIG9iamVjdElkOiB1c2VySWRcbiAgICB9LFxuICAgIGNyZWF0ZWRXaXRoLFxuICAgIHJlc3RyaWN0ZWQ6IGZhbHNlLFxuICAgIGV4cGlyZXNBdDogUGFyc2UuX2VuY29kZShleHBpcmVzQXQpXG4gIH07XG5cbiAgaWYgKGluc3RhbGxhdGlvbklkKSB7XG4gICAgc2Vzc2lvbkRhdGEuaW5zdGFsbGF0aW9uSWQgPSBpbnN0YWxsYXRpb25JZFxuICB9XG5cbiAgT2JqZWN0LmFzc2lnbihzZXNzaW9uRGF0YSwgYWRkaXRpb25hbFNlc3Npb25EYXRhKTtcbiAgLy8gV2UgbmVlZCB0byBpbXBvcnQgUmVzdFdyaXRlIGF0IHRoaXMgcG9pbnQgZm9yIHRoZSBjeWNsaWMgZGVwZW5kZW5jeSBpdCBoYXMgdG8gaXRcbiAgY29uc3QgUmVzdFdyaXRlID0gcmVxdWlyZSgnLi9SZXN0V3JpdGUnKTtcblxuICByZXR1cm4ge1xuICAgIHNlc3Npb25EYXRhLFxuICAgIGNyZWF0ZVNlc3Npb246ICgpID0+IG5ldyBSZXN0V3JpdGUoY29uZmlnLCBtYXN0ZXIoY29uZmlnKSwgJ19TZXNzaW9uJywgbnVsbCwgc2Vzc2lvbkRhdGEpLmV4ZWN1dGUoKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBBdXRoLFxuICBtYXN0ZXIsXG4gIG5vYm9keSxcbiAgcmVhZE9ubHksXG4gIGdldEF1dGhGb3JTZXNzaW9uVG9rZW4sXG4gIGdldEF1dGhGb3JMZWdhY3lTZXNzaW9uVG9rZW4sXG4gIGNyZWF0ZVNlc3Npb24sXG59O1xuIl19